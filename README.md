# Application-3
Wokwi link: https://wokwi.com/projects/434252090011411457
Analysis Questions 

Polling vs. Interrupt: In your own words, why is using an ISR + semaphore to signal the logger task more efficient or more responsive than having the task constantly poll the button status? What problems of polling does this design avoid?
Using an ISR with a semaphore is more efficient and responsive than polling because it gets rid of unnecessary CPU usage. Polling is constantly checking the status of the button wasting processing time even when nothing is happening. With an ISR the processor is only alerted when the button is pressed. The ISR then signals the semaphore to unblock any task waiting on it. This avoids problems like high CPU utlization, reponse latency and missed button presses. 

ISR Design: Why must we use special FreeRTOS APIs (functions with FromISR in their name) inside an ISR? What could go wrong if a regular blocking call (e.g. xSemaphoreTake) was called inside an ISR?
The issue starts with the fact that ISRs and tasks are not the same thing. ISRs run immediately when something happens like a button press but tasks are the chunks of code managed and scheduled by FreeRTOS. Regular blocking calls are designed for tasks which stop until somethings happens and if they were to be used on ISRs the system may get confused and crash or behave unpredictably. The FromISR are designed specifically for ISRs meaning they don't block, work quickly and tell the scheduler if a high-priority task should run next. 

Real-Time Behavior: Assume the LightSensorTask is running (e.g. it just started reading the ADC) at the moment the button is pressed. Describe what happens in the system when that interrupt fires. Include the roles of interrupt priority, the xHigherPriorityTaskWoken/portYIELD_FROM_ISR mechanism, and task priorities in determining what code runs next. Does the logger task preempt the sensor task immediately, or does it wait until the sensor task blocks? Why?
When the button is pressed the ISR executes even if the LightSensorTask is running. The ISR signals the semaphore using xSemaphoreGiveFromISR(). If xHigherPriorityTaskWoken is set to pdTRUE, then portYIELD_FROM_ISR() is called prompting for a context switch. Since the LoggerTask has the highest priority, it preempts LightSensorTask immediately which allows for low-latency event handling.

Core Affinity: All tasks were pinned to Core 1. If we hadn’t pinned tasks (allowing them to run on either core), what nondeterministic behaviors might occur in this lab when the button is pressed? (Consider that the ISR is handled on a particular core and the unblocked task might run on a different core if not pinned – how could that complicate the sequence?) What benefits did pinning to one core provide for understanding this lab?
If tasks were not pinned then the logger task might be scheduled on a different core than the ISR. Because the ISR runs on a specific core, this could cause non-deterministic behavior like delayed semaphore handling or things executing out of order. Pinning all tasks to Core 1 allows for consistent, predictable behavior during testing and debugging. 

Light Sensor Logging: In your implementation, how did you handle the sensor data sharing between the LightSensorTask and the LoggerTask? Did you use any form of mutual exclusion or copying to prevent conflicts? If the logger task runs at a higher priority while the sensor task is in the middle of writing to the buffer, what issues could arise and how could they be mitigated in a more robust design (consider data integrity)?
I used a circular buffer without explicit synchronization. If the logger runs while the sensor is updating the buffer then there is a possibility it could read corrupted data. A solution to this would be to protect the buffer using a mutex or a double-buffered scheme where the logger only reads a portion of the data after the sensor task completes its update. Initially when creating my code this is not something I thought to add. 

Task Priorities: If we accidentally assigned the LoggerTask a lower priority (say 1) and the Blink task a higher priority (say 3), describe what would happen when the button is pressed. Would the log still dump immediately? Why or why not? Relate this to the concept of preemptive scheduling and priority inversion (if any).
If LoggerTask had a lower priority than BlinkTask, pressing the button would not immediately trigger the logger. The blink task would continue to run since it is a higher priority cause a delay for the log. This shows priority inversion where a lower priority task is blocked by a higher priority one. The system would still work but logging would be delayed unless priority inheritance was used. 

Resource Usage: The button ISR defers a potentially long operation (compressing and printing log data) to a task. Chapter 7 of Mastering FreeRTOS suggests keeping ISRs short. What are the reasons for minimizing work in ISRs in a real-time system? List two reasons and connect them to this lab (hint: think about interrupt nesting, scheduler ticking, or other tasks’ latencies).
Two reasons why ISRs should be kept for is to avoid interrupt blocking and minimize jitter. Long ISRs can prevent other interupts from being serviced causing deadlines to be missed. Not only that but they introduce variability in task execution timing. In the lab I avoided these by using a semaphore to having the compression and printing done by a task instead of the ISR itself. 

Chapter Connections: Identify one concept from the readings (“Mastering the FreeRTOS Kernel” Ch. 7 or the “Practical RT Systems” Ch. 8) that you applied in your solution. Briefly quote or paraphrase the resource and explain how your implementation reflects that concept. For example, you might mention “Using a binary semaphore to synchronize an ISR and a task without polling, as suggested in the text..."
The concept my design applies from the book is "Use a binary semaphore to synchronize an ISR with a task." In the books it says that doing this allows most of the interrupt processing to happen in a task which is more efficient and flexible. I implemented  this by using xSemaphoreGiveFromISR in the button ISR and xSemaphoreTake in the logger task to achieve low latency and non-blocking logging. 
